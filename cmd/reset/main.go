package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/ast"
	"go/format"
	"go/token"
	"go/types"
	"log"
	"os"
	"path/filepath"
	"strings"

	"golang.org/x/tools/go/packages"
)

// комментарий, помечающий структуру для генерации Reset.
const resetComment = "generate:reset"

func main() {
	flag.Parse()

	if err := run(); err != nil {
		log.Printf("reset generator failed: %v", err)
		os.Exit(1)
	}
}

func run() error {
	cfg := &packages.Config{
		Mode: packages.NeedName |
			packages.NeedSyntax |
			packages.NeedTypes |
			packages.NeedTypesInfo |
			packages.NeedFiles,
		Dir: ".",
	}

	pkgs, err := packages.Load(cfg, "./...")
	if err != nil {
		return fmt.Errorf("packages.Load: %w", err)
	}

	if packages.PrintErrors(pkgs) > 0 {
		// ошибки парсинга пакетов считаем фатальными
		return fmt.Errorf("there are packages with errors")
	}

	for _, pkg := range pkgs {
		if err := processPackage(pkg); err != nil {
			return err
		}
	}

	return nil
}

func processPackage(pkg *packages.Package) error {
	var buf bytes.Buffer

	var methodsGenerated int

	// пройдёмся по файлам пакета
	for _, file := range pkg.Syntax {
		fileMethods, err := generateForFile(&buf, pkg, file)
		if err != nil {
			return err
		}
		methodsGenerated += fileMethods
	}

	if methodsGenerated == 0 {
		// нечего генерировать
		return nil
	}

	// оборачиваем сгенерированные методы прологом с пакетом
	var out bytes.Buffer
	fmt.Fprintln(&out, "// Code generated by cmd/reset; DO NOT EDIT.")
	fmt.Fprintln(&out)
	fmt.Fprintf(&out, "package %s\n\n", pkg.Name)
	out.Write(buf.Bytes())

	formatted, err := format.Source(out.Bytes())
	if err != nil {
		// если форматирование не удалось, пишем как есть, но ошибку возвращаем
		log.Printf("warning: go/format failed for package %s: %v", pkg.PkgPath, err)
		formatted = out.Bytes()
	}

	// reset.gen.go кладём в ту же директорию, где лежит первый файл пакета
	if len(pkg.GoFiles) == 0 {
		return nil
	}
	dir := filepath.Dir(pkg.GoFiles[0])
	target := filepath.Join(dir, "reset.gen.go")

	if err := os.WriteFile(target, formatted, 0o644); err != nil {
		return fmt.Errorf("write %s: %w", target, err)
	}

	return nil
}

func generateForFile(buf *bytes.Buffer, pkg *packages.Package, file *ast.File) (int, error) {
	var generated int

	for _, decl := range file.Decls {
		gen, ok := decl.(*ast.GenDecl)
		if !ok || gen.Tok != token.TYPE {
			continue
		}

		// проверяем комментарии над блоком типов
		if !hasResetComment(gen.Doc) {
			continue
		}

		for _, spec := range gen.Specs {
			ts, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := ts.Type.(*ast.StructType)
			if !ok {
				continue
			}

			if err := generateResetMethod(buf, pkg, ts.Name.Name, st); err != nil {
				return generated, err
			}
			generated++
		}
	}

	return generated, nil
}

func hasResetComment(group *ast.CommentGroup) bool {
	if group == nil {
		return false
	}
	for _, c := range group.List {
		if strings.Contains(c.Text, resetComment) {
			return true
		}
	}
	return false
}

func generateResetMethod(buf *bytes.Buffer, pkg *packages.Package, typeName string, st *ast.StructType) error {
	receiverName := strings.ToLower(typeName[:1])
	fmt.Fprintf(buf, "func (%s *%s) Reset() {\n", receiverName, typeName)
	fmt.Fprintf(buf, "\tif %s == nil {\n\t\treturn\n\t}\n\n", receiverName)

	for _, field := range st.Fields.List {
		// пропускаем анонимные и встроенные поля
		if len(field.Names) == 0 {
			continue
		}
		for _, nameIdent := range field.Names {
			fieldName := nameIdent.Name
			typ := pkg.TypesInfo.TypeOf(field.Type)
			if typ == nil {
				continue
			}
			generateFieldReset(buf, pkg.Types, receiverName, fieldName, typ)
		}
	}

	fmt.Fprintln(buf, "}")
	fmt.Fprintln(buf)
	return nil
}

func generateFieldReset(buf *bytes.Buffer, pkgTypes *types.Package, recv, field string, t types.Type) {
	// снимаем алиасы
	t = t.Underlying()

	switch tt := t.(type) {
	case *types.Basic:
		fmt.Fprintf(buf, "\t%s.%s = %s\n", recv, field, zeroValueForBasic(tt))
	case *types.Slice:
		fmt.Fprintf(buf, "\t%s.%s = %s.%s[:0]\n", recv, field, recv, field)
	case *types.Map:
		fmt.Fprintf(buf, "\tclear(%s.%s)\n", recv, field)
	case *types.Pointer:
		generatePointerReset(buf, pkgTypes, recv, field, tt)
	case *types.Struct:
		// если у структуры есть метод Reset, вызываем его
		if hasResetMethod(tt, pkgTypes) {
			if methodOnValue(tt, pkgTypes) {
				fmt.Fprintf(buf, "\t%s.%s.Reset()\n", recv, field)
			} else {
				fmt.Fprintf(buf, "\t(&%s.%s).Reset()\n", recv, field)
			}
		}
	}
}

func zeroValueForBasic(b *types.Basic) string {
	info := b.Info()
	switch {
	case info&types.IsBoolean != 0:
		return "false"
	case info&types.IsInteger != 0,
		info&types.IsFloat != 0,
		info&types.IsComplex != 0:
		return "0"
	case info&types.IsString != 0:
		return `""`
	default:
		// для прочих базовых типов (rune, byte и т.п.) достаточно нуля
		return "0"
	}
}

func generatePointerReset(buf *bytes.Buffer, pkgTypes *types.Package, recv, field string, p *types.Pointer) {
	elem := p.Elem().Underlying()

	// если по указателю лежит тип с методом Reset, вызываем его
	if hasResetMethod(p.Elem(), pkgTypes) {
		fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, field)
		fmt.Fprintf(buf, "\t\t%s.%s.Reset()\n", recv, field)
		fmt.Fprintln(buf, "\t}")
		return
	}

	switch et := elem.(type) {
	case *types.Basic:
		fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, field)
		fmt.Fprintf(buf, "\t\t*%s.%s = %s\n", recv, field, zeroValueForBasic(et))
		fmt.Fprintln(buf, "\t}")
	case *types.Slice:
		fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, field)
		fmt.Fprintf(buf, "\t\t*%s.%s = (*%s.%s)[:0]\n", recv, field, recv, field)
		fmt.Fprintln(buf, "\t}")
	case *types.Map:
		fmt.Fprintf(buf, "\tif %s.%s != nil {\n", recv, field)
		fmt.Fprintf(buf, "\t\tclear(*%s.%s)\n", recv, field)
		fmt.Fprintln(buf, "\t}")
	}
}

func hasResetMethod(t types.Type, pkgTypes *types.Package) bool {
	m := lookupMethod(t, pkgTypes, "Reset")
	if m == nil {
		return false
	}
	// ожидаем сигнатуру func() или func(*T)
	sig, ok := m.Type().(*types.Signature)
	if !ok {
		return false
	}
	return sig.Params().Len() == 0 && sig.Results().Len() == 0
}

func methodOnValue(t types.Type, pkgTypes *types.Package) bool {
	// проверяем наличие метода Reset непосредственно на типе t (а не только на *t)
	ms := types.NewMethodSet(t)
	if sel := ms.Lookup(pkgTypes, "Reset"); sel != nil {
		if _, ok := sel.Obj().(*types.Func); ok {
			return true
		}
	}
	return false
}

func lookupMethod(t types.Type, pkgTypes *types.Package, name string) *types.Func {
	if m := types.NewMethodSet(t).Lookup(pkgTypes, name); m != nil {
		if fn, ok := m.Obj().(*types.Func); ok {
			return fn
		}
	}
	return nil
}
